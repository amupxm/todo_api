
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sqlc: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/amupxm/todo_api/db/sqlc/db.go (9.5%)</option>
				
				<option value="file1">github.com/amupxm/todo_api/db/sqlc/store.go (0.0%)</option>
				
				<option value="file2">github.com/amupxm/todo_api/db/sqlc/todo.sql.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0

package db

import (
        "context"
        "database/sql"
        "fmt"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

func Prepare(ctx context.Context, db DBTX) (*Queries, error) <span class="cov0" title="0">{
        q := Queries{db: db}
        var err error
        if q.createTodoStmt, err = db.PrepareContext(ctx, CreateTodo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query CreateTodo: %w", err)
        }</span>
        <span class="cov0" title="0">if q.createUserStmt, err = db.PrepareContext(ctx, CreateUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query CreateUser: %w", err)
        }</span>
        <span class="cov0" title="0">if q.deleteTodoStmt, err = db.PrepareContext(ctx, DeleteTodo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query DeleteTodo: %w", err)
        }</span>
        <span class="cov0" title="0">if q.deleteUserStmt, err = db.PrepareContext(ctx, DeleteUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query DeleteUser: %w", err)
        }</span>
        <span class="cov0" title="0">if q.getTodoByIDStmt, err = db.PrepareContext(ctx, GetTodoByID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query GetTodoByID: %w", err)
        }</span>
        <span class="cov0" title="0">if q.getTodosByUserStmt, err = db.PrepareContext(ctx, GetTodosByUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query GetTodosByUser: %w", err)
        }</span>
        <span class="cov0" title="0">if q.getUserStmt, err = db.PrepareContext(ctx, GetUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query GetUser: %w", err)
        }</span>
        <span class="cov0" title="0">if q.listTodosStmt, err = db.PrepareContext(ctx, ListTodos); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query ListTodos: %w", err)
        }</span>
        <span class="cov0" title="0">if q.toggleTodoStmt, err = db.PrepareContext(ctx, ToggleTodo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query ToggleTodo: %w", err)
        }</span>
        <span class="cov0" title="0">if q.updateTodoStmt, err = db.PrepareContext(ctx, UpdateTodo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query UpdateTodo: %w", err)
        }</span>
        <span class="cov0" title="0">if q.updateUserStmt, err = db.PrepareContext(ctx, UpdateUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error preparing query UpdateUser: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;q, nil</span>
}

func (q *Queries) Close() error <span class="cov0" title="0">{
        var err error
        if q.createTodoStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.createTodoStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing createTodoStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.createUserStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.createUserStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing createUserStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.deleteTodoStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.deleteTodoStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing deleteTodoStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.deleteUserStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.deleteUserStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing deleteUserStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.getTodoByIDStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.getTodoByIDStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing getTodoByIDStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.getTodosByUserStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.getTodosByUserStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing getTodosByUserStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.getUserStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.getUserStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing getUserStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.listTodosStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.listTodosStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing listTodosStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.toggleTodoStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.toggleTodoStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing toggleTodoStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.updateTodoStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.updateTodoStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing updateTodoStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">if q.updateUserStmt != nil </span><span class="cov0" title="0">{
                if cerr := q.updateUserStmt.Close(); cerr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error closing updateUserStmt: %w", cerr)
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        switch </span>{
        case stmt != nil &amp;&amp; q.tx != nil:<span class="cov0" title="0">
                return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)</span>
        case stmt != nil:<span class="cov0" title="0">
                return stmt.ExecContext(ctx, args...)</span>
        default:<span class="cov8" title="1">
                return q.db.ExecContext(ctx, query, args...)</span>
        }
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        switch </span>{
        case stmt != nil &amp;&amp; q.tx != nil:<span class="cov0" title="0">
                return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)</span>
        case stmt != nil:<span class="cov0" title="0">
                return stmt.QueryContext(ctx, args...)</span>
        default:<span class="cov8" title="1">
                return q.db.QueryContext(ctx, query, args...)</span>
        }
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        switch </span>{
        case stmt != nil &amp;&amp; q.tx != nil:<span class="cov0" title="0">
                return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)</span>
        case stmt != nil:<span class="cov0" title="0">
                return stmt.QueryRowContext(ctx, args...)</span>
        default:<span class="cov8" title="1">
                return q.db.QueryRowContext(ctx, query, args...)</span>
        }
}

type Queries struct {
        db                 DBTX
        tx                 *sql.Tx
        createTodoStmt     *sql.Stmt
        createUserStmt     *sql.Stmt
        deleteTodoStmt     *sql.Stmt
        deleteUserStmt     *sql.Stmt
        getTodoByIDStmt    *sql.Stmt
        getTodosByUserStmt *sql.Stmt
        getUserStmt        *sql.Stmt
        listTodosStmt      *sql.Stmt
        toggleTodoStmt     *sql.Stmt
        updateTodoStmt     *sql.Stmt
        updateUserStmt     *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db:                 tx,
                tx:                 tx,
                createTodoStmt:     q.createTodoStmt,
                createUserStmt:     q.createUserStmt,
                deleteTodoStmt:     q.deleteTodoStmt,
                deleteUserStmt:     q.deleteUserStmt,
                getTodoByIDStmt:    q.getTodoByIDStmt,
                getTodosByUserStmt: q.getTodosByUserStmt,
                getUserStmt:        q.getUserStmt,
                listTodosStmt:      q.listTodosStmt,
                toggleTodoStmt:     q.toggleTodoStmt,
                updateTodoStmt:     q.updateTodoStmt,
                updateUserStmt:     q.updateUserStmt,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import "database/sql"

type Store interface {
        Querier
}

type SQLStore struct {
        *Queries
        db *sql.DB
}

func NewStore(db *sql.DB) Store <span class="cov0" title="0">{
        s := &amp;SQLStore{
                db:      db,
                Queries: New(db),
        }
        return s
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: todo.sql

package db

import (
        "context"
        "database/sql"
)

const CreateTodo = `-- name: CreateTodo :one
INSERT INTO todos (user_id, title, task)
VALUES ($1, $2, $3)
RETURNING id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
`

type CreateTodoParams struct {
        UserID int32
        Title  string
        Task   sql.NullString
}

func (q *Queries) CreateTodo(ctx context.Context, arg CreateTodoParams) (Todo, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.createTodoStmt, CreateTodo, arg.UserID, arg.Title, arg.Task)
        var i Todo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Task,
                &amp;i.Completed,
                &amp;i.DueDate,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (username, password, email, first_name, last_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, password, email, first_name, last_name, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
        Username  string
        Password  string
        Email     string
        FirstName sql.NullString
        LastName  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.createUserStmt, CreateUser,
                arg.Username,
                arg.Password,
                arg.Email,
                arg.FirstName,
                arg.LastName,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Password,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
        )
        return i, err
}</span>

const DeleteTodo = `-- name: DeleteTodo :exec
UPDATE todos
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteTodo(ctx context.Context, id int32) error <span class="cov8" title="1">{
        _, err := q.exec(ctx, q.deleteTodoStmt, DeleteTodo, id)
        return err
}</span>

const DeleteUser = `-- name: DeleteUser :one
UPDATE users
SET deleted_at = now()
WHERE id = $1
RETURNING id, username, password, email, first_name, last_name, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (User, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.deleteUserStmt, DeleteUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Password,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
        )
        return i, err
}</span>

const GetTodoByID = `-- name: GetTodoByID :one
SELECT id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
FROM todos
WHERE id = $1
AND  deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetTodoByID(ctx context.Context, id int32) (Todo, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.getTodoByIDStmt, GetTodoByID, id)
        var i Todo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Task,
                &amp;i.Completed,
                &amp;i.DueDate,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const GetTodosByUser = `-- name: GetTodosByUser :many
SELECT id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
FROM todos
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTodosByUser(ctx context.Context, userID int32) ([]Todo, error) <span class="cov8" title="1">{
        rows, err := q.query(ctx, q.getTodosByUserStmt, GetTodosByUser, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Todo{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Todo
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Task,
                        &amp;i.Completed,
                        &amp;i.DueDate,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.DeletedAt,
                        &amp;i.UserID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const GetUser = `-- name: GetUser :one
SELECT id, username, password, email, first_name, last_name, created_at, updated_at, deleted_at
FROM users
WHERE id = $1
AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.getUserStmt, GetUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Password,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
        )
        return i, err
}</span>

const ListTodos = `-- name: ListTodos :many
SELECT id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
FROM todos
WHERE deleted_at IS NULL
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListTodosParams struct {
        Limit  int32
        Offset int32
}

func (q *Queries) ListTodos(ctx context.Context, arg ListTodosParams) ([]Todo, error) <span class="cov8" title="1">{
        rows, err := q.query(ctx, q.listTodosStmt, ListTodos, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Todo{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Todo
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Task,
                        &amp;i.Completed,
                        &amp;i.DueDate,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.DeletedAt,
                        &amp;i.UserID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const ToggleTodo = `-- name: ToggleTodo :one
UPDATE todos
SET completed = NOT completed
WHERE id = $1
RETURNING id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
`

func (q *Queries) ToggleTodo(ctx context.Context, id int32) (Todo, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.toggleTodoStmt, ToggleTodo, id)
        var i Todo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Task,
                &amp;i.Completed,
                &amp;i.DueDate,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const UpdateTodo = `-- name: UpdateTodo :one
UPDATE todos
SET title = $2,
    task = $3
WHERE id = $1
RETURNING id, title, task, completed, due_date, created_at, updated_at, deleted_at, user_id
`

type UpdateTodoParams struct {
        ID    int32
        Title string
        Task  sql.NullString
}

func (q *Queries) UpdateTodo(ctx context.Context, arg UpdateTodoParams) (Todo, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.updateTodoStmt, UpdateTodo, arg.ID, arg.Title, arg.Task)
        var i Todo
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Task,
                &amp;i.Completed,
                &amp;i.DueDate,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const UpdateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2,
    password = $3,
    email = $4,
    first_name = $5,
    last_name = $6
WHERE id = $1
RETURNING id, username, password, email, first_name, last_name, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
        ID        int32
        Username  string
        Password  string
        Email     string
        FirstName sql.NullString
        LastName  sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.queryRow(ctx, q.updateUserStmt, UpdateUser,
                arg.ID,
                arg.Username,
                arg.Password,
                arg.Email,
                arg.FirstName,
                arg.LastName,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Password,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
        )
        return i, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
